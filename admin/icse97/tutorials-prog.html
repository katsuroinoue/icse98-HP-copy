<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<!-- $Id: tutorials-prog.html,v 1.4 1997/02/08 00:29:27 neno Exp $ -->
<HEAD>
<TITLE>ICSE 97 Andvance Program: Tutorials</TITLE>
<LINK rev="Made" href="mailto:icse-97-webmaster@ics.uci.edu">
<META http-equiv="Reply-To" content="icse-97-webmaster@ics.uci.edu">
</HEAD><BODY>

<h1><a href="./"><img src="logos/icse.gif" alt="ICSE 97" align=top border=0></a>
ICSE 97 Advance Program: Tutorials</h1>

Coordinators:<BR>
<b>Mehdi Jazayeri</b>, Technical University of Vienna (Austria)<BR>
<b>Patricia Oberndorf</b>, Software Engineering Institute (USA)<BR>
<b>Ed Weller</b>, Bull HN Information Systems (USA)
<HR>

<H1>SUNDAY, MAY 18, 1997</H1>
 
<H2>FULL DAY TUTORIALS</H2>

<DL COMPACT>
<DT><b>1A</b>        
<DD><b>Software Process Improvement: Methods and Lessons Learned</b>
<DD><i><a href="bios/1A.html"> Bill Curtis</a></i>
<DD>The growing functionality expected from modern products and systems
has  resulted in an exponential growth in the software required to run
them. During  the 1970s and the early 1980s, software developers focused
their investments on advanced workstations, languages, and CASE tools to
improve  their performance. The benefits of these investments were far
lower than promised. A software process movement emerged in the
mid-1980s when shortcomings in managing development and maintenance
processes were recognized as prime inhibitors of growth in software
productivity and quality. 

<P>
 
<DT><b>1B</b>
<DD><b>A Realistic, Commercially Robust Process for the Development
       of Object-Oriented Software Systems</b>
<DD><i><a href="bios/1B.html">Tim Korson</a></i>
<DD>The successful adoption of object technology requires far more
than simply the adoption of an O-O language. Methods for O-O analysis
and design must be selected and configured to fit within an overall
software development process. This session examines the required
elements of a realistic, commercially robust process for the development
of object-oriented software systems. 

<P>
 
<DT><B>1C</b>
<DD><B>Software-Reliability-Engineered Testing (SRET) Practice</b>
<DD><i><a href="bios/1C.html">John D. Musa</a></i>
<DD>SRET is testing of software-based systems which employs reliability
objectives and profiles of system use to speed testing while ensuring
the necessary reliability. It helps us deal with the pressure to get
software-based products to market faster while still meeting customer
reliability needs. You will learn how to perform the major activities of
SRET: defining "necessary" reliability, developing operational profiles,
preparing for testing, executing tests, and interpreting failure data.
The tutorial uses a simple but realistic example throughout to
illustrate the points. 

<P>
 
<DT><B>1D</b>
<DD><B>Java: A Language for Software Engineering</b>
<DD><i><a href="bios/1D.html">Jim Waldo</a></i>
<DD>Java, an object-oriented language designed to allow dynamic loading
of binary code over a network of heterogeneous machines, includes
features to write robust, error-free code and thus presents a platform
for serious software engineering. It is a general purpose,
object-oriented language with such features as garbage collection,
exceptions, strong typing, and a clean separation between classes and
interfaces, allowing secure, robust, reliable programs. We will examine
the packages that allow Java to be used in traditional distributed
systems programming and for more advanced, Java-only environments that
support the Remote Method Invocation system. 

<P>
</DL COMPACT> 
<H2>HALF DAY TUTORIALS</H2>

<H2><i>Morning</i></H2>
<DL COMPACT> 


<DT><B>2A</b>
<DD><B>Software Interoperability: Principles and Practice</B>
<DD><i><a href="bios/2A.html">Jack Wielden, Alan Kaplan</i></a>
<DD>Software interoperability is fundamental to such topics as
development based on components, reuse, and  infrastructure for
distributed or network-based systems. As a result, a variety of (often
partial) approaches to interoperability have appeared, each offering a
potential solution to interoperability problems.  Yet what these
approaches offer, how they compare, and exactly what problems they are
solving is generally unclear. Some foundations for understanding and
evaluating interoperability problems and proposed approaches for solving
those problems.

<P>
<DT><B>2B</b>
<DD><B>Distributed Software Architectures</B>
<DD><i><A HREF="bios/2B.html">Jeff Kramer, Jeff Magee</i></a>
<DD>Software architectures has been identified as a critical design
concern when bridging the gap between system requirements and
implementation,  particularly in large, complex software systems.
Software Architecture is the structure of the components of a program or
system,  their interrelationships, and principles and guidelines
governing their design and  evolution over time. It provides a clear and
well-defined level at which to describe, understand, and analyse system
designs.  
 
<P>
<DT><B>2C</b>
<DD><B>Effective Use of COTS Software in Long-Lived Systems</b>
<DD><I><A HREF="bios/2C.html">W. Morven Gentleman</a></i>
<DD>This tutorial looks at kinds of COTS software components that can be
used in  long lived systems, and the technology available for building
around them. The potential benefits and risks of this approach  to
systems are examined. Modifications of conventional development
processes are required to focus on where time and cost  expenditures
occur, and where risks arise.

</DL COMPACT>

<H2><I>Afternoon</I></H2>
<DL COMPACT> 

<DT><B>3A</b>
<DD><B>Rigorous Requirements for Real-Time Systems Evolution
       and Application of the SCR Method</B>
<DD><I><A HREF="bios/3A.html">Stuart Faulk, Connie Heitmeyer</i></a>
<DD>SCR, a practical formal requirements method, can reduce critical
errors and decrease costs in industrial development of embedded,
high-assurance systems. Requirements errors remain the most intractable
and costly problem in embedded software development. Formal methods
offer techniques for early error detection and correction but are widely
perceived as impractical for large, complex, embedded systems. SCR has
systematically addressed the problems of industrial use of formal
requirements methods. The resulting methods and tools offer a proven,
practical, industrial-strength  approach for formal specification and
analysis of critical system requirements.

<P>
 
<DT><B>3B</b>
<DD><B>Software and  Business Process Technology</B>
<DD><I><A HREF="bios/3B.html">Volker Gruhn, Wilhelm Schaefer</i></a>
<DD>he state-of-the-art technology in software process and business
process technology and its exploitation in an industrial context
includes languages, tools, and substrates (database and operating system
functionality) being used to model, analyse, and execute business and
software processes. The industrial context is based on building, using,
and selling a complete workflow environment including tools for
modeling, analysing, and executing workflows. This environment called
LEU (LION Environment) is used in various industrial sectors like real
estate, software process, and insurance. 
<P>
 
<DT><B>3C</b>
<DD><B>An Introduction to OMG/CORBA</b>
<DD><I><A HREF="bios/3C.html">Wolfgang Emmerich</a></i>
<DD>The Common Object Request Broker Architecture (CORBA) standard
adopted by the Object Management Group (OMG) is the industry standard
middleware for heterogeneous and distributed object-oriented computing.
Participants will be provided with an overview of the different
constituents of the CORBA standard. Although the main focus of the
tutorial is on the standard and its rationales, participants will also
be provided with a brief overview of the most important products
implementing CORBA.

</DL COMPACT>
<HR>

<H1>MONDAY, MAY 19, 1997</H1>
<H2>FULL DAY TUTORIALS</H2>
<DL COMPACT>

<DT><B>4A</b>
<DD><B>The Experience Factory: How to Build and Run One</B>
<DD><I><A HREF="bios/4A.html">Frank McGarry, Victor Basili</i></a>
<DD>This course presents the fundamental concepts behind software
process and  product improvement using measurement and evaluation in an
Experience Factory Organization. It will  provide a set of examples
associated with understanding the software engineering process, product,
and environment, improving it over time and packaging experience in the
form of models and  measures to create an experience base that can be
reused by future projects. It discusses how  this approach is being used
in the Software Engineering Laboratory (SEL) at NASA/ Goddard Space
Flight Center and how it has been expanded to other NASA sites and to
other production environments in private corporations such as Computer
Sciences Corporation (CSC). 

<P>
 
<DT><B>4B</b>
<DD><B>The Personal Process in Software Engineering</B>
<DD><I><A HREF="bios/4B.html">Watts Humphrey, James Over</i></a>
<DD>The PSP method uses quality management principles and the Capability
Maturity Model (CMM) framework and uses sound engineering principles
in software development and maintenance work.  The principal message of
the PSP is that engineers should use process management concepts to
identify and perfect the methods that are most effective for them.
Engineers using PSP significantly improve the quality of their work,
learn how to plan their projects, and improve their productivity.
Average quality improvements of five to ten times are normal, as are
productivity  improvements of 25% or more.
<DL><DD>
<SMALL><SMALL>
<i>Personal Software Process, PSP, Capability Maturity 
      Model, and CMM are service marks of Carnegie Mellon 
      University.</i>
</SMALL></SMALL>
</DL>
<P>

 
<DT><B>4C</b>
<DD><B>Making Requirements Measurable</b>
<DD><i><A HREF="bios/4C.html">Bashar Nuseibeh, Suzanne Robertson</i></a>
<DD>Participants in this interactive full-day tutorial examine
measurability by building a requirements specification for a familiar
system. After presenting an overview of requirements engineering
activities, the tutorial focuses on how to measure requirements for
testability, relevance, completeness, consistency, coherency,
traceability and satisfaction. A requirements template is used as a
guide to discovering requirements and building the specification. A
requirement is RmeasurableS if there is an unambiguous way of
determining whether a given solution fits that requirement.
<P>
 
<DT><B>4D</b>
<DD><B>Defining Families: The Commonality Analysis</B>
<DD><I><A HREF="bios/4D.html">Mark Ardis, David Weiss</I></a>
<DD>One approach of systematically engineering software domains is to
develop families of software and to invest in facilities for rapidly
producing family members. This full-day tutorial describes the
commonality analysis process, a systematic approach to analyzing
families. The result of the analysis forms the basis for designing
reusable assets that can rapidly produce family members. A practice
commonality analysis will be guided by experienced users of the
process.
<P>

<DT><B>4E</b>
<DD><B>Evaluating Software Technology</b>
<DD><I><A HREF="bios/4E.html">Shari Pfleeger</a></i>
<DD>This tutorial examines the issues involved in evaluating the effects
of software methods and tools on our products, processes and resources.
It reviews measurement theory and the basics of experimental design and
analysis to suggest guidelines for how we should investigate the
benefits and costs  of our actions. Principles are illustrated with
actual industrial examples, including two in-depth case studies. In
addition to designing our own investigations, the tutorial enables us to
understand when the results ofothers apply to our own situations. 

</DL COMPACT>

<H2>HALF DAY TUTORIALS</H2>
<H2><I>Morning</I></H2>
<DL COMPACT>

<DT><B>5A</b>
<DD><B>A Survey of Object-Oriented Analysis and Design Methods</B>
<DD><I><A HREF="bios/5A.html">Martin Fowler</a></i>
<DD>Over the last ten years many trees have been sacrificed for writings
on OO methods. This tutorial gives a guided tour of these writings,
pointing out the common techniques, some less-known but valuable
techniques, and where to go for more information. A framework shows how
various techniques fit together. We then explore techniques for
structural, architectural, and behavioral modeling; together with
process techniques used in OO development. The tutorial uses the Unified
Modeling Language as its base, but also discusses important additional
techniques such as model perspectives, design by contract, event
modeling, and the translation process.
<P>
 
<DT><B>5B</b>
<DD><B>Simplifying the Evolution of Java Programs</b>
<DD><I><A HREF="bios/5B.html">Linda  M. Seiter, Karl J. Lieberherr, Doug Orleans</I></a>
<DD>We present an in-depth look at the ability of existing models and
languages to support different forms of reuse and evolution. We present
techniques for achieving dynamic behavior in a static, class-based model
and language. We present the public-domain programming tool Demeter/Java
which implements a special kind of context object, called a visitor
object. To enable the direct expression of visitor objects and to
express traversal strategies for objects in Java, we present a simple
extension to Java (the Demeter/Java language) and show how it is
translated back into Java. The benefits of Demeter/Java are that
programs become more flexible, both structurally and behaviorally Q and
also shorter.
<P>

 
<DT><B>5C</b>
<DD><B>A Primer on Empirical Studies</b>
<DD><A HREF="bios/5C.html"><i>Dewayne Perry, Adam Porter, 
    Larry Votta</I></a>
<DD>A sound empirical basis for software and process engineering and
research by focusing on the basic characteristics of empirical studies.
The key to empirical work is credibility Q everything else follows from
this primary characteristic. We advocate a model in which there is more
control involved, resulting in more detailed information gathered.
Rather than emphasize general phenomenology, we emphasize trying to find
underlying mechanisms. Attendees assess the credibility of empirical
work either as reported in the software engineering literature or as
done by themselves and to apply the results to their own work.
<P>
 
<DT><B>5D</b>
<DD><B>Reverse Engineering Strategies for Software Migration</b>
<DD><I><A HREF="bios/5D.html">Hausi Muller</a></i>
<DD>The need to maintain and improve software and information systems
has risen dramatically over the past decade. Dealing with old software
systems that are billion-dollar assets to corporations and governments
is a critical problem. Migrating and reengineering involves capturing,
preserving, and extending knowledge about software, analyzing and
understanding software, and finally changing, improving, and evolving
software. Reverse engineering approaches have been particularly useful
in the arena of reverse engineering:the process of generating new
information about software. 
<P>
 
<DT><B>5E</b>
<DD><B>Tailoring the CMM for Small Business, Small Organizations and
       Small Projects</B>
<DD><A HREF="bios/5E.html"><I>Judi Brodman, Donna Johnson</i></a>
<DD>A small  organization or project faces issues when implementing a
software process improvement program. Alternative practices that
organizations satisfy the intent of the SEIUs Capability Maturity Model
(CMM) practices and goals and addresses the setting up and sustaining
of a viable processimprovement program. The growth pattern shows areas
of improvement as an organization matures Q  vertical linkages between
process areas through the levels of the CMM and  the evolutionary
definition of metrics through the levels of maturity.

</DL COMPACT>

<H2><I>Afternoon</I></H2>
<DL COMPACT>

<DT><B>6A</b>
<DD><B>Design Patterns for Object-Oriented Software Development</b>
<DD><I><A HREF="bios/6A.html">Wolfgang Pree, Hermann Sikora</i></a>
<DD>Design patterns support the development and reuse of extensible OO
software components. They represent a complimentary enhancement of
existing OO analysis and design (OOAD) methods. The tutorial will give
an overview of state-of-the-art design patterns approaches, including
pattern catalogs and framework patterns. A selection of useful patterns
will be discussed in detail. The tutorial will also introduce hot spot
cards, which have proved to be a useful communications vehicle between
domain experts and software engineers in order to exploit the potential
of design patterns. 

 
<P>
<DT><B>6B</b>
<DD><B>Formal Methods for Broadband and Multimedia Systems</b>
<DD><I><A HREF="bios/6B.html">Stefan Fischer, Stefan Leue</i></a>
<DD>Formal methods have been applied successfully to specify
RtraditionalS communication protocols, services, and network
applications. With high-speed networks, new distributed applications
impose requirements on the communication subsystem that are different
from those on traditional systems. To meet application-level performance
requirements, highly efficient techniques to implement communication
software have been developed.  Formal description techniques (in
particular, SDL and Estelle) can be used for the requirements
specification, design, and implementation stages in the life-cycle of
broadband communication systems. 
 
<P>
<DT><B>6C</b>
<DD><B>Software Engineering Data Analysis Techniques</b>
<DD><i><A HREF="bios/6C.html">Amrit L. Goel</a></i>
<DD>During the past few years, there has been an increasing emphasis on
the use of quantitative measures for monitoring and controlling software
projects. As a result, collection of product and processdata has become
a standard practice in major software development organizations. While
there has been a growing emphasis on the collection of metrics data,
relatively very little work has been done on the systematic use of
appropriate data analysis techniques. For metrics or measurement
undertakings to be successful, we feel that it is essential to address
both the data collection and analysis activities as mutually
inseparable. 
 
<P>
<DT><B>6D</b>
<DD><B>Comprehension and Evolution of Legacy Software</b>
<DD><i><A HREF="bios/6D.html">Vaclav Rajlich</a></i>
<DD>Legacy systems have one or several of the following attributes: they
were implemented many years ago,  their technology became obsolete,
their structure deteriorated, they represent a large investment, they
contain business rules not recorded elsewhere, they cannot be easily
replaced, or the original authors are not available. Software
comprehension typically consumes more than a half of the difficult effor
of maintaining legacy systems. The tutorial will give an overview of the
available techniques and tools.
 
<P>
<DT><B>6E</b>
<DD><B>European and American Software Process Maturity Models
       and Assessments</B>
<DD><I><A HREF="bios/6E.html">Marilyn Bush</a></i>
<DD>How do assessments generate increased productivity? How do software
process assessments work? What principles underlie all current software
process improvement  models worldwide? Four major software process
improvement models are on the international scene: ISO 9001 and 9000 3,
Bootstrap, the SEI Capability Maturity Model (CMM) and Software Process
Improvement and Capability Determination (SPICE). All these models
acknowledge similar state of the practice principles of good software
quality development process, but each involves a different take on
assessing organizational process maturity. 

</DL COMPACT>

<HR>
<ADDRESS>
<A HREF="webmaster.html">
&lt;icse-97-webmaster@ics.uci.edu&gt;</A><BR>
<A HREF="http://www.ics.uci.edu/icse97/">
1997 International Conference on Software Engineering</A>
</ADDRESS>
Last modified: 07 Feb 1997 
</BODY></HTML>
